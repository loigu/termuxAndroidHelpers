#!/bin/bash

is_downloaded()
{
	grep "$1" ~/downloaded
}

recode_one()
{
	local name=$(find . -maxdepth 1 -regex ".*\[${1}\]\.[^.]*" -print -quit)
	[ ! -f "$name" ] && echo "_FAIL: can't find $1 ($name), not recoding" >&2 && return 1

	echo -e "\n\t_START: $name\n"
	# don't pass on formats/filters
	af='' vf='' recode-media.sh -S "$inplace" "$name"
	[ "$?" = 0 ] && echo -e "\n\t_SUCC: $name\n" >&2 || echo -e "\n\t_FAIL: $name\n" >&2
}

get_one()
{
	local id=$(echo "$1" |sed -e 's/.*\?v=\([^&]*\).*/\1/')
	[ -z "$force" ] && is_downloaded "$id" && echo "already downloaded, pass -f to force download" >&2 && return 2
	
	[ -z "$vf" ] && local format="$af" || local format="($vf)+($af)"

	yt-dlp -c -f "$format" -N "$frag" --progress-delta 2 $follow_playlist --embed-metadata --embed-chapters $extra "$1" && \
		echo "$id" >> ~/downloaded
	[ "$recode" = y ] && recode_one "$id" &
}

_is_sourced()
{
        # https://unix.stackexchange.com/a/215279
        [ "${#FUNCNAME[@]}" -ge 2 ] \
        && [ "${FUNCNAME[0]}" = '_is_sourced' ] \
        && [ "${FUNCNAME[1]}" = 'source' ]
}

print_help()
{
	echo -e "[af=139 vf=239 frag=40 follow_playlist=--yes-playlist extra=...]\n\t$0 [-h] [-ri] [-f] url1 [url2...]"
}

parse_args()
{
	while getopts  "frhi" arg; do
		case $arg in
			h) print_help; exit 0 ;;
			f) export force=y ;;
			r) export recode=y ;;
			i) export inplace='-i' ;;
			*) echo "unknown arg $arg" >&2
			   print_help
			   exit 1 ;;
		esac
	done
	shift $(($OPTIND - 1))
}

[ -z "$af" ] && export af="wa[protocol=https][format_note*=original]/wa[protocol=https][format_note*=Defailt]/wa[format_note*=original]/wa[format_note*=Default]/wa"

[ -z "$frag" ] && export frag=40
[ -z "$follow_playlist" ] && export follow_playlist="--no-playlist"

if ! _is_sourced; then
	parse_args "$@"

	ret=0
	for url in "$@"; do
		get_one "$url" || ret=1
	done

	exit $ret
fi

